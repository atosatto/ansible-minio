- hosts: minio
  vars_files:
    - ./../resources/vars.yml
  vars:
    minio_layouts:
      server1:
        server_addr: ":9091"
      server2:
        server_addr: ":9092"

    mc_alias_name: 'molecule-test'
    bucket_names:
      - 'public'
      - 'assets'
      - 'test-bucket'
    minio_server_host: "{{ groups['minio'] | first }}"

  tasks:
    # NOTE: in order to get the facts from each 'minio' machine, the play runs
    #       on 'minio', but the minio client (mc) is only invoked on one instance
    - when: inventory_hostname == (groups['minio'] | difference([minio_server_host]) | last)
      block:
        # NOTE: dynamic variable values generated by a function ('lookup' in this case)
        #       is only interpolated during runtime. In order to stay with the same dynamic
        #       value across the whole play, it is set as a fact in the beginning, instead of
        #       defining it in the 'vars' section above
        - set_fact:
            test_file_dynamic:
              name: 'dynamic-test.txt'
              content: "{{ lookup('password', '/dev/null chars=ascii_lowercase,ascii_uppercase,digits length=12') }}"
            test_file_static:
              name: 'static-test.txt'
              content: |-
                some file content
                uploaded to minio
                and downloaded again

        - name: "configuring mc by setting up alias: {{ mc_alias_name }}"
          vars:
            # NOTE: based on tasks/install-server.yml:set-fact.minio_server_cluster_nodes
            minio_server_ip: >-
              {{
                (
                  hostvars[minio_server_host][
                    'ansible_' + hostvars[minio_server_host]['minio_network_interface']
                  ]['ipv4']['address']
                  if (
                    hostvars[minio_server_host]['minio_network_interface'] is defined
                    and hostvars[minio_server_host]['minio_network_interface'] | length > 0
                  )
                  else hostvars[minio_server_host].ansible_default_ipv4.address
                )
                | default(hostvars[minio_server_host].ansible_all_ipv4_addresses[0])
              }}
          shell: >-
            mc alias set \
              {{ mc_alias_name }} \
              http://{{ minio_server_ip }}{{ minio_layouts.server1.server_addr }} \
              '{{ minio_access_key }}' \
              '{{ minio_secret_key }}'

        - name: removing unneeded default aliases
          shell: >-
            mc alias remove {{ item }}
          loop:
            - 'gcs'
            - 's3'
            - 'play'

        - name: creating buckets
          shell: >-
            mc mb --ignore-existing {{ mc_alias_name }}/{{ item }}
          loop: "{{ bucket_names }}"

        - name: listing all existing buckets
          shell: >-
            mc ls {{ mc_alias_name }}
          register: test_created_buckets
        - name: verifying that buckets exist
          assert:
            that:
              - test_created_buckets.stdout_lines | length == bucket_names | length

        - name: "making the bucket: '{{ bucket_names[0] }}' world-accessible"
          shell: >-
            mc policy set {{ bucket_names[0] }} {{ mc_alias_name }}/public
        - name: tempdir
          tempfile:
            state: directory
          register: minio_test_tmpdir

        - name: generating dynamic test file
          copy:
            content: "{{ test_file_dynamic.content }}"
            dest: "{{ minio_test_tmpdir.path }}/{{ test_file_dynamic.name }}"
        - name: uploading dynamic test file into bucket
          shell: >-
            mc cp \
              {{ minio_test_tmpdir.path }}/{{ test_file_dynamic.name }} \
              {{ mc_alias_name }}/{{ bucket_names[0] }}/{{ test_file_dynamic.name }}
        - name: downloading dynamic test file again
          shell: >-
            mc cp \
              {{ mc_alias_name }}/{{ bucket_names[0] }}/{{ test_file_dynamic.name }} \
              {{ minio_test_tmpdir.path }}/{{ test_file_dynamic.name }}.new
        - name: read downloaded dynamic file content again
          shell: >-
            cat {{ minio_test_tmpdir.path }}/{{ test_file_dynamic.name }}.new
          register: test_file_dynamic_content_downloaded
        - name: comparing content of both dynamic file versions
          assert:
            that:
              - test_file_dynamic.content == test_file_dynamic_content_downloaded.stdout

        - name: checking whether static file already exists in bucket
          shell: >-
            mc find {{ mc_alias_name }}/{{ bucket_names[0] }} --name={{ test_file_static.name }}
          register: test_file_static_exists
        - when: not test_file_static_exists.failed and test_file_static_exists.stdout | length <= 0
          block:
          - name: generating static test file
            copy:
              content: "{{ test_file_static.content }}"
              dest: "{{ minio_test_tmpdir.path }}/{{ test_file_static.name }}"
          - name: uploading static test file into bucket
            shell: >-
              mc cp \
                {{ minio_test_tmpdir.path }}/{{ test_file_static.name }} \
                {{ mc_alias_name }}/{{ bucket_names[0] }}/{{ test_file_static.name }}
        - name: downloading static test file again
          shell: >-
            mc cp \
              {{ mc_alias_name }}/{{ bucket_names[0] }}/{{ test_file_static.name }} \
              {{ minio_test_tmpdir.path }}/{{ test_file_static.name }}.new
        - name: read downloaded static file content again
          shell: >-
            cat {{ minio_test_tmpdir.path }}/{{ test_file_static.name }}.new
          register: test_file_static_content_downloaded
        - name: comparing content of both static file versions
          assert:
            that:
              - test_file_static.content == test_file_static_content_downloaded.stdout

        - name: "checking whether it is possible to get the information for alias: {{ mc_alias_name }}"
          shell: >-
            mc admin info {{ mc_alias_name }}
          register: minio_admin_info
        - debug:
            var: minio_admin_info.stdout_lines
        - name: "checking whether it is possible to export the configuration for alias: {{ mc_alias_name }}"
          shell: >-
            mc admin config export {{ mc_alias_name }}
          register: minio_admin_config
        - debug:
            var: minio_admin_config.stdout_lines
